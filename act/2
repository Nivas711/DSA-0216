import cv2
import numpy as np
import matplotlib.pyplot as plt
from google.colab import files
from io import BytesIO
from PIL import Image

def load_image():
    print("Choose an option:")
    print("1. Upload your own image")
    print("2. Use a sample image")
    
    choice = input("Enter 1 or 2: ")
    
    if choice == "1":
        print("Please upload an image file...")
        uploaded = files.upload()
        filename = list(uploaded.keys())[0]
        file_bytes = uploaded[filename]
        image = Image.open(BytesIO(file_bytes))
        img = cv2.cvtColor(np.array(image), cv2.COLOR_RGB2BGR)
    else:
        img = np.zeros((400, 400, 3), dtype=np.uint8)
        img.fill(255)
        
        cv2.rectangle(img, (50, 50), (150, 150), (0, 0, 255), -1)
        cv2.circle(img, (300, 100), 50, (0, 255, 0), -1)
        cv2.ellipse(img, (200, 300), (80, 40), 0, 0, 360, (255, 0, 0), -1)
        
        triangle = np.array([[100, 250], [200, 350], [50, 350]], np.int32)
        cv2.fillPoly(img, [triangle], (255, 255, 0))
    
    return img

def preprocess_image(img):
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    blurred = cv2.GaussianBlur(gray, (5, 5), 0)
    _, thresh = cv2.threshold(blurred, 127, 255, cv2.THRESH_BINARY_INV)
    
    return gray, thresh

def find_and_draw_contours(img, thresh, min_area=100):
    contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
    
    filtered_contours = [cnt for cnt in contours if cv2.contourArea(cnt) > min_area]
    
    img_contours = img.copy()
    img_filled = img.copy()
    img_bbox = img.copy()
    img_approx = img.copy()
    
    print(f"Found {len(filtered_contours)} contours (area > {min_area})")
    
    cv2.drawContours(img_contours, filtered_contours, -1, (0, 255, 0), 2)
    cv2.drawContours(img_filled, filtered_contours, -1, (0, 255, 0), -1)
    
    for i, cnt in enumerate(filtered_contours):
        x, y, w, h = cv2.boundingRect(cnt)
        cv2.rectangle(img_bbox, (x, y), (x+w, y+h), (255, 0, 0), 2)
        
        epsilon = 0.02 * cv2.arcLength(cnt, True)
        approx = cv2.approxPolyDP(cnt, epsilon, True)
        cv2.drawContours(img_approx, [approx], -1, (0, 0, 255), 2)
        
        area = cv2.contourArea(cnt)
        perimeter = cv2.arcLength(cnt, True)
        
        print(f"Contour {i+1}: Area={area:.1f}, Perimeter={perimeter:.1f}, Vertices={len(approx)}")
    
    return img_contours, img_filled, img_bbox, img_approx, filtered_contours

def get_contour_properties(contours):
    properties = []
    
    for i, cnt in enumerate(contours):
        area = cv2.contourArea(cnt)
        perimeter = cv2.arcLength(cnt, True)
        
        M = cv2.moments(cnt)
        if M['m00'] != 0:
            cx = int(M['m10'] / M['m00'])
            cy = int(M['m01'] / M['m00'])
        else:
            cx, cy = 0, 0
        
        x, y, w, h = cv2.boundingRect(cnt)
        
        aspect_ratio = float(w) / h if h != 0 else 0
        
        rect_area = w * h
        extent = float(area) / rect_area if rect_area != 0 else 0
        
        properties.append({
            'index': i,
            'area': area,
            'perimeter': perimeter,
            'centroid': (cx, cy),
            'bounding_box': (x, y, w, h),
            'aspect_ratio': aspect_ratio,
            'extent': extent
        })
    
    return properties

def visualize_results(original, gray, thresh, img_contours, img_filled, img_bbox, img_approx):
    fig, axes = plt.subplots(2, 4, figsize=(20, 10))
    
    original_rgb = cv2.cvtColor(original, cv2.COLOR_BGR2RGB)
    img_contours_rgb = cv2.cvtColor(img_contours, cv2.COLOR_BGR2RGB)
    img_filled_rgb = cv2.cvtColor(img_filled, cv2.COLOR_BGR2RGB)
    img_bbox_rgb = cv2.cvtColor(img_bbox, cv2.COLOR_BGR2RGB)
    img_approx_rgb = cv2.cvtColor(img_approx, cv2.COLOR_BGR2RGB)
    
    axes[0, 0].imshow(original_rgb)
    axes[0, 0].set_title('Original Image')
    axes[0, 0].axis('off')
    
    axes[0, 1].imshow(gray, cmap='gray')
    axes[0, 1].set_title('Grayscale')
    axes[0, 1].axis('off')
    
    axes[0, 2].imshow(thresh, cmap='gray')
    axes[0, 2].set_title('Binary Threshold')
    axes[0, 2].axis('off')
    
    axes[0, 3].imshow(img_contours_rgb)
    axes[0, 3].set_title('Contour Outline')
    axes[0, 3].axis('off')
    
    axes[1, 0].imshow(img_filled_rgb)
    axes[1, 0].set_title('Filled Contours')
    axes[1, 0].axis('off')
    
    axes[1, 1].imshow(img_bbox_rgb)
    axes[1, 1].set_title('Bounding Boxes')
    axes[1, 1].axis('off')
    
    axes[1, 2].imshow(img_approx_rgb)
    axes[1, 2].set_title('Approximated Polygons')
    axes[1, 2].axis('off')
    
    axes[1, 3].axis('off')
    
    plt.tight_layout()
    plt.show()

def main():
    print("=" * 60)
    print("Contour Tracing with OpenCV")
    print("=" * 60)
    
    img = load_image()
    print(f"Image loaded: {img.shape}")
    
    gray, thresh = preprocess_image(img)
    
    img_contours, img_filled, img_bbox, img_approx, contours = find_and_draw_contours(img, thresh)
    
    properties = get_contour_properties(contours)
    
    print("\n" + "=" * 60)
    print("Contour Properties:")
    print("=" * 60)
    for prop in properties:
        print(f"\nContour {prop['index'] + 1}:")
        print(f"  Area: {prop['area']:.2f}")
        print(f"  Perimeter: {prop['perimeter']:.2f}")
        print(f"  Centroid: {prop['centroid']}")
        print(f"  Aspect Ratio: {prop['aspect_ratio']:.2f}")
        print(f"  Extent: {prop['extent']:.2f}")
    
    visualize_results(img, gray, thresh, img_contours, img_filled, img_bbox, img_approx)
    
    return contours, properties

if __name__ == "__main__":
    contours, properties = main()
    print("\nâœ“ Contour tracing complete!")
    print("The 'contours' and 'properties' variables are now available for further analysis.")
